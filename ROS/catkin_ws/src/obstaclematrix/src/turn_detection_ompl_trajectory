/*
store trajectory points generated by OMPL into a vector for further analysis
*/

// void get_trajectory_points(string trajectory_file)							//reads trajectory file and stores x,y coordinates in a vector variable.
// {
//     std::string line;
//     int count = 0;
//     std::ifstream traj_file(trajectory_file.c_str());
//     // cout<<"------------ trajectory points ------------------\n";
//     while (std::getline(traj_file, line))
//     {
// 		std::istringstream stream(line);
// 	    float x_coordinate, y_coordinate;
// 	    if (!(stream >> x_coordinate >> y_coordinate)) 
// 	    {  
// 	      cout<<"not reading points"<<endl;        // error
//           break; 
// 	    } 
// 	    // add trajectory points
// 	    trajectory_points[0].push_back((int)x_coordinate);
// 	    trajectory_points[1].push_back((int)y_coordinate);
// 	    count++;
// 	    // cout<<trajectory_points[0].size()<<" ";
// 	    // printf("%d %d " , (int)x_coordinate, (int)y_coordinate);
// 	    cout<<"\n";
// 	}
// 	// cout<<"count = "<<count<<endl;
// 	traj_count = count;
// 	traj_file.close();
//     // cout<<"---------------------------------------------\n";
// }


// /*
//   This function detect a turn at or before 20 meters
//   by reading waypoint file
// */
// void detect_turn(const std::string trajectory_file)
// {
//   double turn_threshold = 60, delta;                                        //define turn_threshold in degrees// if bearing is greater than this threshold a turn is detected.
//   int i, j;
//   float angle_1, angle_2,dist;
//   int x1, y1, x2, y2, x3, y3, d21x, d32x, d21y, d32y;
//   float tollerance = 0.4;											 //error tollerance in distance ; range = [0,1]
//   // vector<bool> is_right;											 //set to 1 if a right turn is detected
//   // vector<float>	turn_distance;
//   turn_count = 0;
//   std_msgs::String turn_direction;
//   std::stringstream temp;

//   get_trajectory_points(trajectory_file);
//   // cout<<"trajectory_count = "<<traj_count<<endl;
//   for(i = trajectory_points[0].size()-traj_count; i < trajectory_points[0].size()-2; ++i)
//   {
//     x1 = trajectory_points[0].at(i);
//     y1 = trajectory_points[1].at(i);
//     x2 = trajectory_points[0].at(i+1);
//     y2 = trajectory_points[1].at(i+1);
//     x3 = trajectory_points[0].at(i+2);
//     y3 = trajectory_points[1].at(i+2);

//     d21x = x2-x1;
//     d32x = x3-x2;
//     d21y = y2-y1;
//     d32y = y3-y2;
//   // 	cout<<"\t\t number = "<<trajectory_points[0].at(i)
//   // 		<<"\t\t next number = "<<trajectory_points[0].at(i+1)
//   // 		<<"\t\t next to next number = "<<trajectory_points[0].at(i+2)
// 		// <<endl<<endl;

//     angle_1 = rad2deg(atan2(d21y,d21x));
//     angle_2 = rad2deg(atan2(d32y,d32x));
//     delta = angle_2 - angle_1;
//     /***************************************************************
// 	SIGN CONVENTION (VERIFIED VISUALLY)

// 	if delta is positive, RIGHT turn is detected
// 	ELSE if delta is negative, LEFT turn is detected

//     ***************************************************************/

// 	    if ( (fabs(delta)) >= turn_threshold )
// 	    {
// 	    	turn_count++;
// 	    	// temp.str("");
// 	    	// temp<<"straight";
// 	    	dist = sqrt(pow((x2-home_x),2)+pow((y2-home_y),2));
// 	    	// turn_distance.push_back(dist);
// 	    	traj_turn1_point[0].push_back(trajectory_points[0].at(i+1));
// 			traj_turn1_point[1].push_back(trajectory_points[1].at(i+1));

// 	    	cout<<"\ndistance to upcoming turn = "<<dist<<endl;
// 	    	// 	<<"angle difference = "<<(angle_2 - angle_1)<<endl;

// 			// cout<<"\n\n-------TURN DETECTED------\n\n"<<endl;
// 			if( delta < 0 )
// 		    {
// 		    	temp.str("");
// 		    	temp<<"left";
// 		    	ROS_INFO("Left turn");
// 		    }
		
// 			    else if( delta > 0 )
// 			    {
// 			    	temp.str("");
// 			    	temp<<"right";
// 			    	ROS_INFO("Right turn");
// 			    }

			
// 			turn_direction.data = temp.str();
			
// 			if (dist > ((1 - tollerance )*dist_to_traffic_light) && dist < ((1 + tollerance)*dist_to_traffic_light))
// 			{
// 				trajectory_turn_pub.publish(turn_direction);
// 			}

// 		    //  cout<<"turn trajectory point ** X **= "<<traj_turn_point[0]<<endl;
//   			// cout<<"turn trajectory point ** Y **= "<<traj_turn_point[1]<<endl;
// 		}

// 		else
// 		{
// 			temp.str("");
// 	    	temp<<"straight";
// 	    	turn_direction.data = temp.str();
// 			trajectory_turn_pub.publish(turn_direction);
// 		}
		
		
//     curr_traj_index++;
//   }
// }


